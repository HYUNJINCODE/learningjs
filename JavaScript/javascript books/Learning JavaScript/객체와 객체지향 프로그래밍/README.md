# 객체와 객체지향 프로그래밍

배열과 마찬가지로 자바스크립트 객체 역시 컨테이너이지만, 크게 다음 두 측면에서 배열과 다르다.

- 배열은 값을 가지며 각 값에는 숫자형 인덱스가 있다. 객체는 프로퍼티를 가지며 각 프로퍼티에는 문자열이나 심볼 인덱스가 있다.
- 배열에는 순서가 있다. 즉 arr[0]은 arr[1]보다 앞에 있다. 반면 객체에는 그런 순서가 보장되지 않는다.obj.a가 obj.b보다 앞에 있다고 말할 수 없다.

프로퍼티는 키(문자열 또는 심볼)과 값으로 구성된다. 객체의 진짜 특징은 키를 통해 프로퍼티에 접근할 수 있다는 점이다.

## 9.1 프로퍼티 나열

프로퍼티 나열에서 기억해야 할 것은 순서가 보장되지 않는다는 점이다. 여러 번 테스트를 해 봤는데도 프로퍼티가 입력한 순서대로 나열될 수도 있다. 하지만 자바스크립트가 그런 순서를 명시적으로 보장하는 것도 아니고, 브라우저나 노드 등의 프로그램에서 속도나 효율 향상을 목적으로 언제든 바꿀 수도 있다. 따라서 입증 할 수 없는 테스트를 근거로 확실하다는 착각에 빠지면 안된다. 객체 프로퍼티에는 순서가 없다.

### 9.1.1 for in

for in 루프에는 키가 심볼인 프로퍼티는 포함되지 않는다.

### 9.1.2 Object.keys

Object.keys 는 객체에서 나열 가능한 문자열 프로퍼티를 배열로 반환한다.

## 9.2 객체지향 프로그래밍

객체지향 프로그래밍은 컴퓨터 과학에서 전통적인 패러다임이다. OOP의 기본 아이디어는 단순하고 직관적이다. 객체는 데이터와 기능을 논리적으로 묶어 놓은 것이다. OOP는 우리가 사물을 이해하는 자연스러운 방식을 반영하도록 설계되었다.
클래스는 어떤 자동차처럼 추상적이고 범용적인것이다. 인스턴스는 특정 자동차처럼 구체적이고 한정적인 것이다. 기능을 메서드라고 부른다. 클래스에 속하지만 특정 인스턴스에 묶이지는 않는 기능을 클래스 메서드라고 한다. 예를 들어 시동을 거는 기능은 클래스 메서드라고 할 수 있다. 인스턴스를 처음 만들때는 생성자가 실행된다. 생성자는 객체 인스턴스를 초기화 한다.

### 9.2.2 클래스는 함수다

ES6에서 class 키워드를 도입하기 전까지, 클래스를 만든다는 것은 곧 클래스 생성자로 사용할 함수를 만든다는 의미였다. class 문법이 훨씬 더 직관적이고 단순하긴 하지만, 사실 class는 단축 문법일 뿐이며 자바스크립트의 클래스 자체가 바뀐 것은 아니다.
클래스는 함수일 뿐이다.

```javascript
function Car(make, model) {
  this.make = make;
  this.model = model;
  this._userGears = ["P", "N", "R", "D"];
}
```

위 코드는 ES5 문법이다.

### 9.2.3 prototype

클래스의 인스턴스에서 사용할 수 있는 메서드라고 하면 그건 프로토타입메서드를 말한다. Car.prototype.shift 처럼 표기할 때가 많다. 그렇다면 프로토타입은 무엇인지, 자바스크립트가 프로토타입 체인을 통해 어떻게 동적 디스패치를 구현하는지 알아보자.
모든 함수에는 prototype이라는 특별한 프로퍼티가 있다. 일반적인 함수에서는 프로토타입을 사용할 일이 없지만, 객체 생성자로 동작하는 함수에서는 프로토타입이 대단히 중요하다.함수의 prototype 프로퍼티가 중요해지는 시점은 new 키워드로 새 인스턴스를 만들었을 때이다. new 키워드로 만든 새 객체는 생성자의 prototype 프로퍼티에 접근할 수 있다. 객체 인스턴스는 생성자의 prototype 프로퍼티를 \_\_proto\_\_ 프로퍼티에 저장한다.
프로토타입에서 중요한 것은 동적 디스패치라는 메커니즘이다. 여기서 디스패치는 메서드 호출과 같은 의미이다.객체의 프로퍼티나 메서드에 접근하려고 할때, 그런 프로퍼티나 메서드가 존재하지 않으면 자바스크립트는 객체의 프로토타입에서 해당 프로퍼티나 메서드를 찾는다. 클래스의 인스턴스는 모두 같은 프로토타입을 공유하므로 프로토타입에 프로퍼티나 메서드가 있으면 해당 클래스의 인스턴스는 모두 그 프로퍼티나 메서드에 접근할 수 있다.
인스턴스에서 메서드나 프로퍼티를 정의하면 프로토타입에 있는 것을 가리는 효과가 있다. 자바스크립트는 가장먼저 인스턴스를 체크하고 거기에 없으면 프로토타입을 체크하기 때문이다. 예로, 만약 인스턴스에 어떤 메서드가 없다면, 생성자가 생성해주지않았고, 자신이 가지고 있을 수 있다. 따라서 인스턴스는 자기자신을 체크하고 자기를 만든 클래스로가서 체크를 한번 더 한후 만약 존재하면 그 메서드를 실행한다. 이때 만약 인스턴스에 같은 이름의 메서드를 생성하버린다고 생각해보자 그렇다면 프로토타입과 자신에 같은이름의 메서드가 존재한다. 이제 인스턴스는 자기 자신의 메서드를 사용하고, 프로토타입의 메서드는 호출하지 않는다.

### 9.2.4 정적 메서드

메서드에는 인스턴스 메서드 외에도 정적 메서드(클래스 메서드)가 있다. 이 메서드는 특정 인스턴스에 적용되지 않는다. 정적 메서드에서 this는 인스턴스가 아니라 클래스 자체에 묶인다. 하지만 일반적으로 정적 메서드에는 this 대신 클래스 이름을 사용하는 것이 좋은 습관이다.
정적 메서드는 클래스에 관련되지만 인스턴스와는 관련이 없는 범용적인 작업에 사용된다. 예제로 자동차 식별 번호 (VIN)을 붙이는 메서드를 생각해보자. 개별 자동차가 자신만의 VIN을 생성한다는 것은 불가능하다. 다른 자동차에 같은 VIN이 이미 부여됐는지 자동차는 모른다. VIN을 할당한다는 것은 자동차 전체를 대상으로 하는 추상적인 개념이므로 정적 메서드로 사용하는게 어울린다. 정적 메서드는 여러 인스턴스를 대상으로 하는 작업에도 종종 쓰인다. 예를 들어서 두자동차의 제조사와 모델이 모두 같으면 true를 반환하는 areSimilar 메서드 , 두 자동차의 VIN이 같으면 true 를 반환하는 areSame 메서드 를 예로 들 수 있다.

```javascript
class Car {
  static getNextVin() {
    return Car.nextVin++;
    //this.nextVin++ 라고 써도 되지만, Car를 앞에 쓰면 정적 메서드라는 점을 상기하기 쉽다.
  }
  constructor(make, model) {
    this.model = model;
    this.make = make;
    this.vin = Car.getNextVin();
  }
  static areSimilar(car1, car2) {
    return car1.make === car2.make && car1.model === car2.model;
  }
  static areSame(car1, car2) {
    return car1.vin === car2.vin;
  }
}
Car.nextVin = 0;
const car1 = new Car("Tesla", "S");
const car2 = new Car("Mazda", "3");
const car3 = new Car("Mazda", "3");
car1.vin; //0
car2.vin; //1
car3.vin; //2
Car.areSimilar(car1, car2); //false
Car.areSimilar(car1, car3); //true
Car.areSame(car2, car3); // false
Car.areSame(car2, car2); //true
```
